{"version":3,"file":"typescript-result.esm.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * Util\n */\n\nfunction isAsyncFn(fn: Function) {\n  return fn.constructor.name === \"AsyncFunction\";\n}\n\nfunction isResult(value: unknown): value is Result<any, any, any> {\n  return value instanceof Ok || value instanceof Err;\n}\n\ninterface SyncThenable {\n  isSync: true;\n  then<Fn extends () => Promise<any>>(cb: Fn): ReturnType<Fn>;\n  then<Fn extends () => any>(cb: Fn): SyncThenable;\n}\n\n// Utility to emulate a Promise, but where 'then' is initially sync, unless the callback\n// returns a real Promise\n// This utility function is mainly used within Result.combine in order to loop over callbacks\n// that may be sync or async -> we only want to return a Promise when we absolutely need to\nfunction syncThenable(): SyncThenable {\n  function then<Fn extends () => Promise<any>>(cb: Fn): ReturnType<Fn>;\n  function then<Fn extends () => any>(cb: Fn): SyncThenable;\n  function then(cb: any) {\n    const result = cb();\n    if (result instanceof Promise) {\n      return result;\n    }\n\n    return syncThenable();\n  }\n\n  return {\n    isSync: true,\n    then,\n  };\n}\n\n// utility fn to loop over (async) callbacks or values\nfunction forEachValueThunkOrPromise<T>(\n  items: unknown[],\n  execFn: (value: T) => boolean, // false means error, true means success here\n  foldFn: () => unknown\n) {\n  // we want to break the iteration when an error ocurred\n  let shouldBreak = false;\n\n  const result = items.reduce((prev: { then: Function }, valueOrThunk) => {\n    return prev.then(() => {\n      // if an error ocurred, return early\n      if (shouldBreak) {\n        return null;\n      }\n\n      function run(value: T) {\n        const isSuccess = execFn(value);\n        if (!isSuccess) {\n          shouldBreak = true;\n        }\n      }\n\n      // if the current item is a function -> run it\n      const valueOrPromise =\n        typeof valueOrThunk === \"function\" ? valueOrThunk() : valueOrThunk;\n\n      // if the 'unpacked' item is an actual Promise...\n      if (valueOrPromise instanceof Promise) {\n        return valueOrPromise.then(run);\n      }\n\n      // Apparently we're dealing with sync stuff...\n      return run(valueOrPromise);\n    });\n  }, syncThenable());\n\n  if ((result as SyncThenable).isSync) {\n    return foldFn();\n  }\n\n  return result.then(() => {\n    return foldFn();\n  });\n}\n\n/**\n * Types\n */\n\nexport type Result<\n  ErrorType,\n  OkType,\n  RollbackFn extends RollbackFunction = any\n> = Ok<ErrorType, OkType, RollbackFn> | Err<ErrorType, OkType, RollbackFn>;\n\ninterface IResult<ErrorType, OkType> {\n  /**\n   * **Indicates whether the Result is of type Ok**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * if (result.isSuccess()) {\n   *   result.value; // we now have access to 'value'\n   * } else {\n   *   result.error; // we now have access to 'error'\n   * }\n   * ```\n   */\n  isSuccess(): this is Ok<ErrorType, OkType, any>;\n\n  /**\n   * **Indicates whether the Result is of type Error**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * if (result.isFailure()) {\n   *   result.error; // we now have access to 'error'\n   * } else {\n   *   result.value; // we now have access to 'value'\n   * }\n   * ```\n   */\n  isFailure(): this is Err<ErrorType, OkType, any>;\n\n  /**\n   * **Returns the error on failure or null on success**\n   *\n   * Example:\n   * ```tsx\n   * // on failure...\n   * const result = thisWillFail();\n   * const error = result.errorOrNull(); // error is defined\n   *\n   * // on success...\n   * const result = thisWillSucceed();\n   * const error = result.errorOrNull(); // error is null\n   * ```\n   */\n  errorOrNull(): ErrorType | null;\n\n  /**\n   * **Returns the value on success or null on failure**\n   *\n   * Example:\n   * ```tsx\n   * // on success...\n   * const result = thisWillSucceed();\n   * const value = result.getOrNull(); // value is defined\n   *\n   * // on failure...\n   * const result = thisWillFail();\n   * const value = result.getOrNull(); // value is null\n   * ```\n   */\n  getOrNull(): OkType | null;\n\n  /**\n   * **Returns a visual representation of the inner value**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * const display = result.toString() // 'Result.Ok(\"value\")' | 'Result.Error(\"error-message\")'\n   * ```\n   */\n  toString(): string;\n\n  /**\n   * **See Result.toString()**\n   */\n  inspect(): string;\n\n  /**\n   * **Returns the result of the onSuccess-callback for the encapsulated value if this instance represents success or the result of onFailure-callback for the encapsulated error if it is failure.**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * const value = result.fold(\n   *    // on success...\n   *    (value) => value * 2,\n   *     // on failure...\n   *    (error) => 4\n   * );\n   * ```\n   */\n  fold<R>(\n    onSuccess: (value: OkType) => R,\n    onFailure: (error: ErrorType) => R\n  ): R;\n  fold<R>(\n    onSuccess: (value: OkType) => Promise<R>,\n    onFailure: (error: ErrorType) => Promise<R>\n  ): Promise<R>;\n\n  /**\n   * **Returns the value on success or a default value on failure**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * const value = result.getOrDefault(2);\n   * ```\n   */\n  getOrDefault(defaultValue: OkType): OkType;\n\n  /**\n   * **Returns the value on success or the return-value of the onFailure-callback on failure**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * const value = result.getOrElse((error) => 4);\n   * ```\n   */\n  getOrElse(onFailure: (error: ErrorType) => OkType): OkType;\n  getOrElse(onFailure: (error: ErrorType) => Promise<OkType>): Promise<OkType>;\n\n  /**\n   * **Returns the value on success or throws the error on failure**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * const value = result.getOrThrow();\n   * ```\n   */\n  getOrThrow(): OkType;\n\n  /**\n   * **Maps a result to another result**\n   * If the result is success, it will call the callback-function with the encapsulated value, which returns another Result.\n   * Nested Results are supported, which will basically act as a flat-map.\n   * If the result is failure, it will ignore the callback-function.\n   *\n   * Example:\n   * ```tsx\n   *\n   * class ErrorA extends Error {}\n   * class ErrorB extends Error {}\n   *\n   * function doA(): Result<ErrorA, number> {\n   *  // ...\n   * }\n   *\n   * function doB(value: number): Result<ErrorB, string> {\n   *  // ...\n   * }\n   *\n   * // nested results will flat-map to a single Result...\n   * const result1 = doA().map(value => doB(value)); // Result<ErrorA | ErrorB, string>\n   *\n   * // ...or transform the successful value right away\n   * // note: underneath, the callback is wrapped inside Result.safe() in case the callback\n   * // might throw\n   * const result2 = doA().map(value => value * 2); // Result<ErrorA | Error, number>\n   * ```\n   */\n  map<T>(\n    fn: (value: OkType) => Promise<T>\n  ): Promise<\n    JoinErrorTypes<\n      ErrorType,\n      T extends Result<any, any, any> ? T : Result<Error, T, any>\n    >\n  >;\n  map<T>(\n    fn: (value: OkType) => T\n  ): JoinErrorTypes<\n    ErrorType,\n    T extends Result<any, any, any> ? T : Result<Error, T, any>\n  >;\n\n  /**\n   * **Rolls back things that were successful**\n   * This method is especially useful when working with Result.combine()\n   */\n  rollback(): Result<Error, void> | Promise<Result<Error, void>>;\n}\n\ntype InferErrorType<T extends Result<any, any, any>> = T extends Result<\n  infer Errortype,\n  any,\n  any\n>\n  ? Errortype\n  : never;\n\ntype InferOkType<T extends Result<any, any, any>> = T extends Result<\n  any,\n  infer OkType,\n  any\n>\n  ? OkType\n  : never;\n\ntype JoinErrorTypes<ErrorType, B extends Result<any, any, any>> = Result<\n  ErrorType | InferErrorType<B>,\n  InferOkType<B>,\n  any\n>;\n\ntype ExtractErrorTypes<Tuple extends any[]> = {\n  [Index in keyof Tuple]: Tuple[Index] extends Result<any, any, any>\n    ? InferErrorType<Tuple[Index]>\n    : never;\n}[number];\n\ntype MapResultTupleToOkTypeTuple<Tuple extends any[]> = {\n  [Index in keyof Tuple]: Tuple[Index] extends Result<any, any, any>\n    ? InferOkType<Tuple[Index]>\n    : never;\n};\n\ntype RollbackFunction = (() => void) | (() => Promise<void>);\n\ntype HasAsyncRollbackFunction<T extends any[]> = {\n  [Index in keyof T]: T[Index] extends () => Promise<infer U> | infer U\n    ? U extends Result<any, any, () => Promise<void>>\n      ? true\n      : false\n    : false;\n}[number] extends false\n  ? false\n  : true;\n\ntype UnwrapThunks<T extends any[]> = {\n  [Index in keyof T]: T[Index] extends () => Promise<infer U>\n    ? U\n    : T[Index] extends () => infer U\n    ? U\n    : T[Index];\n};\n\ntype HasAsyncThunk<T extends any[]> = {\n  [Index in keyof T]: T[Index] extends () => Promise<any> ? true : false;\n}[number] extends false\n  ? false\n  : true;\n\ntype PromiseReturnType<T extends (...args: any) => any> = T extends (\n  ...args: any\n) => Promise<infer U>\n  ? U\n  : never;\n\n/**\n * Creation functions of Result-type\n */\n\nexport namespace Result {\n  /**\n   * **Returns a Result.Ok which contains a encapsulated value**\n   *\n   * Example:\n   * ```tsx\n   * const result = Result.ok(12); // Result<unknown, number>\n   * ```\n   */\n  export function ok<\n    ErrorType extends unknown,\n    OkType,\n    RollbackFn extends RollbackFunction = any\n  >(\n    value?: OkType,\n    rollbackFn?: RollbackFn\n  ): Result<ErrorType, OkType, RollbackFn> {\n    // if (value === null) {\n    //   throw new Error(\n    //     `Expected thruthy valid value as parameter but instead received: null`\n    //   );\n    // }\n\n    return new Ok<ErrorType, OkType, RollbackFn>(\n      value || null!,\n      rollbackFn\n    ) as any;\n  }\n\n  /**\n   * **Returns a Result.Error which contains a encapsulated error**\n   *\n   * Example:\n   * ```tsx\n   * const result = Result.error(new Error(\"Something went wrong!\")); // Result<Error, unknown>\n   * ```\n   */\n  export function error<\n    ErrorType extends unknown,\n    OkType extends unknown,\n    RollbackFn extends RollbackFunction = any\n  >(\n    error: ErrorType,\n    rollbackFn?: RollbackFn\n  ): Result<ErrorType, OkType, RollbackFn> {\n    return new Err<ErrorType, OkType, RollbackFn>(error, rollbackFn);\n  }\n\n  type SafeReturnType<E, T> = T extends Result<any, any, any>\n    ? Result<E | InferErrorType<T>, InferOkType<T>, never>\n    : Result<E, T, never>;\n\n  /**\n   * **Functions as a try-catch, returning the return-value of the callback on success, or the predefined error or caught error on failure **\n   *\n   * Example:\n   * ```tsx\n   * // with caught error...\n   * const result = Result.safe(() => {\n   *   let value = 2;\n   *\n   *   // code that might throw...\n   *\n   *   return value;\n   * }); // Result<Error, number>\n   *\n   * // with predefined error...\n   * class CustomError extends Error {}\n   *\n   * const result = Result.safe(new CustomError(\"Custom error!\"), () => {\n   *   let value = 2;\n   *\n   *   // code that might throw...\n   *\n   *   return value;\n   * }); // Result<CustomError, number>\n   *\n   * // with predefined error Class...\n   * const result = Result.safe(CustomError, () => {\n   *   let value = 2;\n   *\n   *   // code that might throw...\n   *\n   *   return value;\n   * }); // Result<CustomError, number>\n   * ```\n   */\n  export function safe<T>(\n    fn: () => Promise<T>\n  ): Promise<SafeReturnType<Error, T>>;\n  export function safe<T>(fn: () => T): SafeReturnType<Error, T>;\n  export function safe<ErrorType, T>(\n    err: ErrorType | (new (...args: any[]) => ErrorType),\n    fn: () => Promise<T>\n  ): Promise<SafeReturnType<ErrorType, T>>;\n  export function safe<ErrorType, T>(\n    err: ErrorType | (new (...args: any[]) => ErrorType),\n    fn: () => T\n  ): SafeReturnType<ErrorType, T>;\n  export function safe(errOrFn: any, fn?: any) {\n    const hasCustomError = fn !== undefined;\n\n    const execute = hasCustomError ? fn : errOrFn;\n\n    function getError(caughtError: Error) {\n      if (!hasCustomError) {\n        // just forward the original Error\n        return caughtError;\n      }\n\n      // pass the caught error to the specified constructor\n      if (typeof errOrFn === \"function\") {\n        return new errOrFn(caughtError);\n      }\n\n      // return predefined error\n      return errOrFn;\n    }\n\n    try {\n      const resultOrPromise = execute();\n\n      if (resultOrPromise instanceof Promise) {\n        return resultOrPromise\n          .then(okValue => {\n            return isResult(okValue) ? okValue : Result.ok(okValue);\n          })\n          .catch(caughtError => error(getError(caughtError)));\n      }\n\n      return isResult(resultOrPromise)\n        ? resultOrPromise\n        : Result.ok(resultOrPromise);\n    } catch (caughtError) {\n      return error(getError(caughtError));\n    }\n  }\n\n  type CombineResult<\n    T extends (unknown | (() => unknown) | (() => Promise<unknown>))[]\n  > = Result<\n    ExtractErrorTypes<UnwrapThunks<T>>,\n    MapResultTupleToOkTypeTuple<UnwrapThunks<T>>,\n    HasAsyncRollbackFunction<T> extends true ? () => Promise<void> : () => void\n  >;\n\n  /**\n   * **Accepts multiple Results or functions that return Results and returns a singe Result**\n   * Successful values will be placed inside a tuple.\n   *\n   * Example:\n   * ```tsx\n   *\n   * function doA(): Result<Error, string> {}\n   * function doB(value: number): Result<Error, number> {}\n   * function doC(value: string): Result<Error, Date> {}\n   *\n   * const result = Result.combine(\n   *   doA(),\n   *   () => doB(2),\n   *   () => doC(\"hello\")\n   * ); // Result<Error, [string, number, Date]>\n   *\n   * if (result.isSuccess()) {\n   *   result.value; // [string, number, Date]\n   * }\n   * ```\n   */\n\n  export function combine<\n    T extends (unknown | (() => unknown) | (() => Promise<unknown>))[]\n  >(\n    ...items: T\n  ): HasAsyncThunk<T> extends true\n    ? Promise<CombineResult<T>>\n    : CombineResult<T> {\n    if (!items.length) {\n      throw new Error(\"Expected at least 1 argument\");\n    }\n\n    const values: unknown[] = [];\n    const rollbacks: RollbackFunction[] = [];\n    let error: Err<unknown, unknown, any> | null = null;\n\n    function rollback() {\n      const reversedRollbacks = rollbacks.reverse();\n      const wrappedRollbackFns = reversedRollbacks.map(fn => Result.wrap(fn));\n\n      let error: Err<unknown, unknown, any> | null = null;\n\n      return forEachValueThunkOrPromise(\n        wrappedRollbackFns,\n        (result: Result<unknown, unknown>) => {\n          if (result.isFailure()) {\n            error = Result.error<unknown, unknown, any>(result.error) as any;\n            return false;\n          }\n\n          return true;\n        },\n        () => error || ok()\n      );\n    }\n\n    return forEachValueThunkOrPromise(\n      items,\n      (result: Result<unknown, unknown>) => {\n        if (result.isFailure()) {\n          error = Result.error<unknown, unknown>(result.error, rollback) as any;\n          return false;\n        }\n\n        values.push(result.value);\n        rollbacks.push(() => result.rollback());\n        return true;\n      },\n      () => error || ok(values, rollback)\n    );\n  }\n\n  /**\n   * **Transforms an existing function into a function that returns a Result**\n   *\n   * Example:\n   * ```tsx\n   * function add2(value: number) {\n   *  // code that might throw....\n   *\n   *  return value + 2;\n   * }\n   *\n   * const wrappedAdd2 = Result.wrap(add2);\n   *\n   * const result1 = add2(4) // number;\n   * const result2 = wrappedAdd2(4) // Result<Error, number>;\n   * ```\n   */\n\n  export function wrap<Fn extends (...args: any) => Promise<any>>(\n    fn: Fn\n  ): (\n    ...args: Parameters<Fn>\n  ) => Promise<Result<Error, PromiseReturnType<Fn>, never>>;\n  export function wrap<Fn extends (...args: any) => any>(\n    fn: Fn\n  ): (...args: Parameters<Fn>) => Result<Error, ReturnType<Fn>, never>;\n  export function wrap(fn: any) {\n    return function wrapped(...args: any) {\n      try {\n        const resultOrPromise = fn(...args);\n\n        if (resultOrPromise instanceof Promise) {\n          return resultOrPromise\n            .then(okValue => Result.ok(okValue))\n            .catch(err => error(err));\n        }\n\n        return ok(resultOrPromise);\n      } catch (err) {\n        return error(err);\n      }\n    };\n  }\n}\n\n/**\n * Underlying Result types\n */\n\nabstract class Base<\n  ErrorType extends unknown,\n  OkType extends unknown,\n  RollbackFn extends RollbackFunction\n> implements IResult<ErrorType, OkType> {\n  constructor(protected readonly rollbackFn?: RollbackFn) {}\n\n  errorOrNull(): ErrorType | null {\n    if (this.isSuccess()) {\n      return null;\n    }\n\n    return (this as any).error as ErrorType;\n  }\n\n  getOrNull(): OkType | null {\n    if (this.isFailure()) {\n      return null;\n    }\n\n    return (this as any).value as OkType;\n  }\n\n  toString(): string {\n    throw new Error(\"Method not implemented.\");\n  }\n  inspect(): string {\n    return this.toString();\n  }\n\n  fold<R>(\n    onSuccess: (value: OkType) => R,\n    onFailure: (error: ErrorType) => R\n  ): R;\n  fold<R>(\n    onSuccess: (value: OkType) => Promise<R>,\n    onFailure: (error: ErrorType) => Promise<R>\n  ): Promise<R>;\n  fold(onSuccess: any, onFailure: any) {\n    if (this.isFailure()) {\n      return onFailure(this.error);\n    }\n\n    return onSuccess((this as any).value as OkType);\n  }\n\n  getOrDefault(defaultValue: OkType): OkType {\n    if (this.isSuccess()) {\n      return this.value;\n    }\n\n    return defaultValue;\n  }\n\n  getOrElse(onFailure: (error: ErrorType) => OkType): OkType;\n  getOrElse(onFailure: (error: ErrorType) => Promise<OkType>): Promise<OkType>;\n  getOrElse(onFailure: any) {\n    if (this.isSuccess()) {\n      return isAsyncFn(onFailure) ? Promise.resolve(this.value) : this.value;\n    }\n\n    return onFailure((this as any).error as ErrorType);\n  }\n\n  getOrThrow(): OkType {\n    if (this.isFailure()) {\n      throw this.error;\n    }\n\n    return (this as any).value as OkType;\n  }\n\n  isSuccess(): this is Ok<ErrorType, OkType, RollbackFn> {\n    throw new Error(\"Method not implemented.\");\n  }\n  isFailure(): this is Err<ErrorType, OkType, RollbackFn> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  map<T>(\n    fn: (value: OkType) => Promise<T>\n  ): Promise<\n    JoinErrorTypes<\n      ErrorType,\n      T extends Result<any, any, any> ? T : Result<Error, T, any>\n    >\n  >;\n  map<T>(\n    fn: (value: OkType) => T\n  ): JoinErrorTypes<\n    ErrorType,\n    T extends Result<any, any, any> ? T : Result<Error, T, any>\n  >;\n  map(fn: any) {\n    if (this.isFailure()) {\n      return isAsyncFn(fn) ? Promise.resolve(this) : this;\n    }\n\n    const result = Result.safe(() => fn((this as any).value) as any);\n\n    return result as any;\n  }\n\n  rollback(): RollbackFn extends RollbackFunction\n    ? RollbackFn extends () => Promise<void>\n      ? Promise<Result<Error, void>>\n      : Result<Error, void>\n    : void {\n    if (this.rollbackFn) {\n      return this.rollbackFn() as any;\n    }\n\n    return null as any;\n  }\n}\n\nclass Ok<\n  ErrorType extends unknown,\n  OkType extends unknown,\n  RollbackFn extends RollbackFunction\n> extends Base<ErrorType, OkType, RollbackFn> {\n  public readonly value: OkType;\n\n  constructor(val: OkType, rollbackFn?: RollbackFn) {\n    super(rollbackFn);\n    this.value = val;\n  }\n\n  isSuccess(): this is Ok<ErrorType, OkType, RollbackFn> {\n    return true;\n  }\n\n  isFailure(): this is Err<ErrorType, OkType, RollbackFn> {\n    return false;\n  }\n\n  toString(): string {\n    return `Result.Ok(${this.value})`;\n  }\n\n  /**\n   * **Creates and forwards a brand new Result out of the current error or value **\n   */\n  forward(): Result<any, OkType, RollbackFn> {\n    return Result.ok(this.value);\n  }\n}\n\nclass Err<\n  ErrorType extends unknown,\n  OkType extends unknown,\n  RollbackFn extends RollbackFunction\n> extends Base<ErrorType, OkType, RollbackFn> {\n  public readonly error: ErrorType;\n\n  constructor(err: ErrorType, rollbackFn?: RollbackFn) {\n    super(rollbackFn);\n    this.error = err;\n  }\n\n  isSuccess(): this is Ok<ErrorType, OkType, RollbackFn> {\n    return false;\n  }\n\n  isFailure(): this is Err<ErrorType, OkType, RollbackFn> {\n    return true;\n  }\n\n  toString(): string {\n    return `Result.Error(${this.error})`;\n  }\n\n  /**\n   * **Creates and forwards a brand new Result out of the current error or value **\n   */\n  forward(): Result<ErrorType, any, RollbackFn> {\n    return Result.error(this.error);\n  }\n}\n"],"names":["isAsyncFn","fn","constructor","name","isResult","value","Ok","Err","syncThenable","then","cb","result","Promise","isSync","forEachValueThunkOrPromise","items","execFn","foldFn","shouldBreak","reduce","prev","valueOrThunk","run","isSuccess","valueOrPromise","Result","ok","rollbackFn","error","safe","errOrFn","hasCustomError","undefined","execute","getError","caughtError","resultOrPromise","okValue","combine","length","Error","values","rollbacks","rollback","reversedRollbacks","reverse","wrappedRollbackFns","map","wrap","isFailure","push","wrapped","err","Base","errorOrNull","getOrNull","toString","inspect","fold","onSuccess","onFailure","getOrDefault","defaultValue","getOrElse","resolve","getOrThrow","val","forward"],"mappings":";;;;;;AAAA;;;AAIA,SAASA,SAAT,CAAmBC,EAAnB;AACE,SAAOA,EAAE,CAACC,WAAH,CAAeC,IAAf,KAAwB,eAA/B;AACD;;AAED,SAASC,QAAT,CAAkBC,KAAlB;AACE,SAAOA,KAAK,YAAYC,EAAjB,IAAuBD,KAAK,YAAYE,GAA/C;AACD;AASD;AACA;AACA;;;AACA,SAASC,YAAT;AAGE,WAASC,IAAT,CAAcC,EAAd;AACE,QAAMC,MAAM,GAAGD,EAAE,EAAjB;;AACA,QAAIC,MAAM,YAAYC,OAAtB,EAA+B;AAC7B,aAAOD,MAAP;AACD;;AAED,WAAOH,YAAY,EAAnB;AACD;;AAED,SAAO;AACLK,IAAAA,MAAM,EAAE,IADH;AAELJ,IAAAA,IAAI,EAAJA;AAFK,GAAP;AAID;;;AAGD,SAASK,0BAAT,CACEC,KADF,EAEEC,MAFF;AAGEC,MAHF;AAKE;AACA,MAAIC,WAAW,GAAG,KAAlB;AAEA,MAAMP,MAAM,GAAGI,KAAK,CAACI,MAAN,CAAa,UAACC,IAAD,EAA2BC,YAA3B;AAC1B,WAAOD,IAAI,CAACX,IAAL,CAAU;AACf;AACA,UAAIS,WAAJ,EAAiB;AACf,eAAO,IAAP;AACD;;AAED,eAASI,GAAT,CAAajB,KAAb;AACE,YAAMkB,SAAS,GAAGP,MAAM,CAACX,KAAD,CAAxB;;AACA,YAAI,CAACkB,SAAL,EAAgB;AACdL,UAAAA,WAAW,GAAG,IAAd;AACD;AACF;;;AAGD,UAAMM,cAAc,GAClB,OAAOH,YAAP,KAAwB,UAAxB,GAAqCA,YAAY,EAAjD,GAAsDA,YADxD;;AAIA,UAAIG,cAAc,YAAYZ,OAA9B,EAAuC;AACrC,eAAOY,cAAc,CAACf,IAAf,CAAoBa,GAApB,CAAP;AACD;;;AAGD,aAAOA,GAAG,CAACE,cAAD,CAAV;AACD,KAxBM,CAAP;AAyBD,GA1Bc,EA0BZhB,YAAY,EA1BA,CAAf;;AA4BA,MAAKG,MAAuB,CAACE,MAA7B,EAAqC;AACnC,WAAOI,MAAM,EAAb;AACD;;AAED,SAAON,MAAM,CAACF,IAAP,CAAY;AACjB,WAAOQ,MAAM,EAAb;AACD,GAFM,CAAP;AAGD;AAyQD;;;;;IAIiBQ;;AAAjB,WAAiBA;AACf;;;;;;;;AAQA,WAAgBC,EAAhB,CAKErB,KALF,EAMEsB,UANF;AAQE;AACA;AACA;AACA;AACA;AAEA,WAAO,IAAIrB,EAAJ,CACLD,KAAK,IAAI,IADJ,EAELsB,UAFK,CAAP;AAID;;AAlBeF,EAAAA,SAAA,KAAA;AAoBhB;;;;;;;;;AAQA,WAAgBG,KAAhB,CAKEA,KALF,EAMED,UANF;AAQE,WAAO,IAAIpB,GAAJ,CAAuCqB,KAAvC,EAA8CD,UAA9C,CAAP;AACD;;AATeF,EAAAA,YAAA,QAAA;;AA8DhB,WAAgBI,IAAhB,CAAqBC,OAArB,EAAmC7B,EAAnC;AACE,QAAM8B,cAAc,GAAG9B,EAAE,KAAK+B,SAA9B;AAEA,QAAMC,OAAO,GAAGF,cAAc,GAAG9B,EAAH,GAAQ6B,OAAtC;;AAEA,aAASI,QAAT,CAAkBC,WAAlB;AACE,UAAI,CAACJ,cAAL,EAAqB;AACnB;AACA,eAAOI,WAAP;AACD;;;AAGD,UAAI,OAAOL,OAAP,KAAmB,UAAvB,EAAmC;AACjC,eAAO,IAAIA,OAAJ,CAAYK,WAAZ,CAAP;AACD;;;AAGD,aAAOL,OAAP;AACD;;AAED,QAAI;AACF,UAAMM,eAAe,GAAGH,OAAO,EAA/B;;AAEA,UAAIG,eAAe,YAAYxB,OAA/B,EAAwC;AACtC,eAAOwB,eAAe,CACnB3B,IADI,CACC,UAAA4B,OAAO;AACX,iBAAOjC,QAAQ,CAACiC,OAAD,CAAR,GAAoBA,OAApB,GAA8BZ,MAAM,CAACC,EAAP,CAAUW,OAAV,CAArC;AACD,SAHI,WAIE,UAAAF,WAAW;AAAA,iBAAIP,KAAK,CAACM,QAAQ,CAACC,WAAD,CAAT,CAAT;AAAA,SAJb,CAAP;AAKD;;AAED,aAAO/B,QAAQ,CAACgC,eAAD,CAAR,GACHA,eADG,GAEHX,MAAM,CAACC,EAAP,CAAUU,eAAV,CAFJ;AAGD,KAdD,CAcE,OAAOD,WAAP,EAAoB;AACpB,aAAOP,KAAK,CAACM,QAAQ,CAACC,WAAD,CAAT,CAAZ;AACD;AACF;;AArCeV,EAAAA,WAAA,OAAA;AA+ChB;;;;;;;;;;;;;;;;;;;;;;;AAuBA,WAAgBa,OAAhB;sCAGKvB;AAAAA,MAAAA;;;AAIH,QAAI,CAACA,KAAK,CAACwB,MAAX,EAAmB;AACjB,YAAM,IAAIC,KAAJ,CAAU,8BAAV,CAAN;AACD;;AAED,QAAMC,MAAM,GAAc,EAA1B;AACA,QAAMC,SAAS,GAAuB,EAAtC;AACA,QAAId,KAAK,GAAsC,IAA/C;;AAEA,aAASe,QAAT;AACE,UAAMC,iBAAiB,GAAGF,SAAS,CAACG,OAAV,EAA1B;AACA,UAAMC,kBAAkB,GAAGF,iBAAiB,CAACG,GAAlB,CAAsB,UAAA9C,EAAE;AAAA,eAAIwB,MAAM,CAACuB,IAAP,CAAY/C,EAAZ,CAAJ;AAAA,OAAxB,CAA3B;AAEA,UAAI2B,KAAK,GAAsC,IAA/C;AAEA,aAAOd,0BAA0B,CAC/BgC,kBAD+B,EAE/B,UAACnC,MAAD;AACE,YAAIA,MAAM,CAACsC,SAAP,EAAJ,EAAwB;AACtBrB,UAAAA,KAAK,GAAGH,MAAM,CAACG,KAAP,CAAoCjB,MAAM,CAACiB,KAA3C,CAAR;AACA,iBAAO,KAAP;AACD;;AAED,eAAO,IAAP;AACD,OAT8B,EAU/B;AAAA,eAAMA,KAAK,IAAIF,EAAE,EAAjB;AAAA,OAV+B,CAAjC;AAYD;;AAED,WAAOZ,0BAA0B,CAC/BC,KAD+B,EAE/B,UAACJ,MAAD;AACE,UAAIA,MAAM,CAACsC,SAAP,EAAJ,EAAwB;AACtBrB,QAAAA,KAAK,GAAGH,MAAM,CAACG,KAAP,CAA+BjB,MAAM,CAACiB,KAAtC,EAA6Ce,QAA7C,CAAR;AACA,eAAO,KAAP;AACD;;AAEDF,MAAAA,MAAM,CAACS,IAAP,CAAYvC,MAAM,CAACN,KAAnB;AACAqC,MAAAA,SAAS,CAACQ,IAAV,CAAe;AAAA,eAAMvC,MAAM,CAACgC,QAAP,EAAN;AAAA,OAAf;AACA,aAAO,IAAP;AACD,KAX8B,EAY/B;AAAA,aAAMf,KAAK,IAAIF,EAAE,CAACe,MAAD,EAASE,QAAT,CAAjB;AAAA,KAZ+B,CAAjC;AAcD;;AAjDelB,EAAAA,cAAA,UAAA;;AA6EhB,WAAgBuB,IAAhB,CAAqB/C,EAArB;AACE,WAAO,SAASkD,OAAT;AACL,UAAI;AACF,YAAMf,eAAe,GAAGnC,EAAE,MAAF,mBAAxB;;AAEA,YAAImC,eAAe,YAAYxB,OAA/B,EAAwC;AACtC,iBAAOwB,eAAe,CACnB3B,IADI,CACC,UAAA4B,OAAO;AAAA,mBAAIZ,MAAM,CAACC,EAAP,CAAUW,OAAV,CAAJ;AAAA,WADR,WAEE,UAAAe,GAAG;AAAA,mBAAIxB,KAAK,CAACwB,GAAD,CAAT;AAAA,WAFL,CAAP;AAGD;;AAED,eAAO1B,EAAE,CAACU,eAAD,CAAT;AACD,OAVD,CAUE,OAAOgB,GAAP,EAAY;AACZ,eAAOxB,KAAK,CAACwB,GAAD,CAAZ;AACD;AACF,KAdD;AAeD;;AAhBe3B,EAAAA,WAAA,OAAA;AAiBjB,CAvQD,EAAiBA,MAAM,KAANA,MAAM,KAAA,CAAvB;AAyQA;;;;;IAIe4B;AAKb,gBAA+B1B,UAA/B;AAA+B,mBAAA,GAAAA,UAAA;AAA2B;;;;SAE1D2B,cAAA;AACE,QAAI,KAAK/B,SAAL,EAAJ,EAAsB;AACpB,aAAO,IAAP;AACD;;AAED,WAAQ,KAAaK,KAArB;AACD;;SAED2B,YAAA;AACE,QAAI,KAAKN,SAAL,EAAJ,EAAsB;AACpB,aAAO,IAAP;AACD;;AAED,WAAQ,KAAa5C,KAArB;AACD;;SAEDmD,WAAA;AACE,UAAM,IAAIhB,KAAJ,CAAU,yBAAV,CAAN;AACD;;SACDiB,UAAA;AACE,WAAO,KAAKD,QAAL,EAAP;AACD;;SAUDE,OAAA,cAAKC,SAAL,EAAqBC,SAArB;AACE,QAAI,KAAKX,SAAL,EAAJ,EAAsB;AACpB,aAAOW,SAAS,CAAC,KAAKhC,KAAN,CAAhB;AACD;;AAED,WAAO+B,SAAS,CAAE,KAAatD,KAAf,CAAhB;AACD;;SAEDwD,eAAA,sBAAaC,YAAb;AACE,QAAI,KAAKvC,SAAL,EAAJ,EAAsB;AACpB,aAAO,KAAKlB,KAAZ;AACD;;AAED,WAAOyD,YAAP;AACD;;SAIDC,YAAA,mBAAUH,SAAV;AACE,QAAI,KAAKrC,SAAL,EAAJ,EAAsB;AACpB,aAAOvB,SAAS,CAAC4D,SAAD,CAAT,GAAuBhD,OAAO,CAACoD,OAAR,CAAgB,KAAK3D,KAArB,CAAvB,GAAqD,KAAKA,KAAjE;AACD;;AAED,WAAOuD,SAAS,CAAE,KAAahC,KAAf,CAAhB;AACD;;SAEDqC,aAAA;AACE,QAAI,KAAKhB,SAAL,EAAJ,EAAsB;AACpB,YAAM,KAAKrB,KAAX;AACD;;AAED,WAAQ,KAAavB,KAArB;AACD;;SAEDkB,YAAA;AACE,UAAM,IAAIiB,KAAJ,CAAU,yBAAV,CAAN;AACD;;SACDS,YAAA;AACE,UAAM,IAAIT,KAAJ,CAAU,yBAAV,CAAN;AACD;;SAgBDO,MAAA,aAAI9C,EAAJ;;;AACE,QAAI,KAAKgD,SAAL,EAAJ,EAAsB;AACpB,aAAOjD,SAAS,CAACC,EAAD,CAAT,GAAgBW,OAAO,CAACoD,OAAR,CAAgB,IAAhB,CAAhB,GAAwC,IAA/C;AACD;;AAED,QAAMrD,MAAM,GAAGc,MAAM,CAACI,IAAP,CAAY;AAAA,aAAM5B,EAAE,CAAE,KAAY,CAACI,KAAf,CAAR;AAAA,KAAZ,CAAf;AAEA,WAAOM,MAAP;AACD;;SAEDgC,WAAA;AAKE,QAAI,KAAKhB,UAAT,EAAqB;AACnB,aAAO,KAAKA,UAAL,EAAP;AACD;;AAED,WAAO,IAAP;AACD;;;;;IAGGrB;;;AAOJ,cAAY4D,GAAZ,EAAyBvC,UAAzB;;;AACE,8BAAMA,UAAN;AACA,WAAKtB,KAAL,GAAa6D,GAAb;;AACD;;;;UAED3C,YAAA;AACE,WAAO,IAAP;AACD;;UAED0B,YAAA;AACE,WAAO,KAAP;AACD;;UAEDO,WAAA;AACE,0BAAoB,KAAKnD,KAAzB;AACD;AAED;;;;;UAGA8D,UAAA;AACE,WAAO1C,MAAM,CAACC,EAAP,CAAU,KAAKrB,KAAf,CAAP;AACD;;;EAzBOgD;;IA4BJ9C;;;AAOJ,eAAY6C,GAAZ,EAA4BzB,UAA5B;;;AACE,+BAAMA,UAAN;AACA,WAAKC,KAAL,GAAawB,GAAb;;AACD;;;;UAED7B,YAAA;AACE,WAAO,KAAP;AACD;;UAED0B,YAAA;AACE,WAAO,IAAP;AACD;;UAEDO,WAAA;AACE,6BAAuB,KAAK5B,KAA5B;AACD;AAED;;;;;UAGAuC,UAAA;AACE,WAAO1C,MAAM,CAACG,KAAP,CAAa,KAAKA,KAAlB,CAAP;AACD;;;EAzBOyB;;;;"}