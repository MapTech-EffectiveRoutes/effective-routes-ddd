{"version":3,"file":"typescript-result.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * Util\n */\n\nfunction isAsyncFn(fn: Function) {\n  return fn.constructor.name === \"AsyncFunction\";\n}\n\nfunction isResult(value: unknown): value is Result<any, any, any> {\n  return value instanceof Ok || value instanceof Err;\n}\n\ninterface SyncThenable {\n  isSync: true;\n  then<Fn extends () => Promise<any>>(cb: Fn): ReturnType<Fn>;\n  then<Fn extends () => any>(cb: Fn): SyncThenable;\n}\n\n// Utility to emulate a Promise, but where 'then' is initially sync, unless the callback\n// returns a real Promise\n// This utility function is mainly used within Result.combine in order to loop over callbacks\n// that may be sync or async -> we only want to return a Promise when we absolutely need to\nfunction syncThenable(): SyncThenable {\n  function then<Fn extends () => Promise<any>>(cb: Fn): ReturnType<Fn>;\n  function then<Fn extends () => any>(cb: Fn): SyncThenable;\n  function then(cb: any) {\n    const result = cb();\n    if (result instanceof Promise) {\n      return result;\n    }\n\n    return syncThenable();\n  }\n\n  return {\n    isSync: true,\n    then,\n  };\n}\n\n// utility fn to loop over (async) callbacks or values\nfunction forEachValueThunkOrPromise<T>(\n  items: unknown[],\n  execFn: (value: T) => boolean, // false means error, true means success here\n  foldFn: () => unknown\n) {\n  // we want to break the iteration when an error ocurred\n  let shouldBreak = false;\n\n  const result = items.reduce((prev: { then: Function }, valueOrThunk) => {\n    return prev.then(() => {\n      // if an error ocurred, return early\n      if (shouldBreak) {\n        return null;\n      }\n\n      function run(value: T) {\n        const isSuccess = execFn(value);\n        if (!isSuccess) {\n          shouldBreak = true;\n        }\n      }\n\n      // if the current item is a function -> run it\n      const valueOrPromise =\n        typeof valueOrThunk === \"function\" ? valueOrThunk() : valueOrThunk;\n\n      // if the 'unpacked' item is an actual Promise...\n      if (valueOrPromise instanceof Promise) {\n        return valueOrPromise.then(run);\n      }\n\n      // Apparently we're dealing with sync stuff...\n      return run(valueOrPromise);\n    });\n  }, syncThenable());\n\n  if ((result as SyncThenable).isSync) {\n    return foldFn();\n  }\n\n  return result.then(() => {\n    return foldFn();\n  });\n}\n\n/**\n * Types\n */\n\nexport type Result<\n  ErrorType,\n  OkType,\n  RollbackFn extends RollbackFunction = any\n> = Ok<ErrorType, OkType, RollbackFn> | Err<ErrorType, OkType, RollbackFn>;\n\ninterface IResult<ErrorType, OkType> {\n  /**\n   * **Indicates whether the Result is of type Ok**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * if (result.isSuccess()) {\n   *   result.value; // we now have access to 'value'\n   * } else {\n   *   result.error; // we now have access to 'error'\n   * }\n   * ```\n   */\n  isSuccess(): this is Ok<ErrorType, OkType, any>;\n\n  /**\n   * **Indicates whether the Result is of type Error**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * if (result.isFailure()) {\n   *   result.error; // we now have access to 'error'\n   * } else {\n   *   result.value; // we now have access to 'value'\n   * }\n   * ```\n   */\n  isFailure(): this is Err<ErrorType, OkType, any>;\n\n  /**\n   * **Returns the error on failure or null on success**\n   *\n   * Example:\n   * ```tsx\n   * // on failure...\n   * const result = thisWillFail();\n   * const error = result.errorOrNull(); // error is defined\n   *\n   * // on success...\n   * const result = thisWillSucceed();\n   * const error = result.errorOrNull(); // error is null\n   * ```\n   */\n  errorOrNull(): ErrorType | null;\n\n  /**\n   * **Returns the value on success or null on failure**\n   *\n   * Example:\n   * ```tsx\n   * // on success...\n   * const result = thisWillSucceed();\n   * const value = result.getOrNull(); // value is defined\n   *\n   * // on failure...\n   * const result = thisWillFail();\n   * const value = result.getOrNull(); // value is null\n   * ```\n   */\n  getOrNull(): OkType | null;\n\n  /**\n   * **Returns a visual representation of the inner value**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * const display = result.toString() // 'Result.Ok(\"value\")' | 'Result.Error(\"error-message\")'\n   * ```\n   */\n  toString(): string;\n\n  /**\n   * **See Result.toString()**\n   */\n  inspect(): string;\n\n  /**\n   * **Returns the result of the onSuccess-callback for the encapsulated value if this instance represents success or the result of onFailure-callback for the encapsulated error if it is failure.**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * const value = result.fold(\n   *    // on success...\n   *    (value) => value * 2,\n   *     // on failure...\n   *    (error) => 4\n   * );\n   * ```\n   */\n  fold<R>(\n    onSuccess: (value: OkType) => R,\n    onFailure: (error: ErrorType) => R\n  ): R;\n  fold<R>(\n    onSuccess: (value: OkType) => Promise<R>,\n    onFailure: (error: ErrorType) => Promise<R>\n  ): Promise<R>;\n\n  /**\n   * **Returns the value on success or a default value on failure**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * const value = result.getOrDefault(2);\n   * ```\n   */\n  getOrDefault(defaultValue: OkType): OkType;\n\n  /**\n   * **Returns the value on success or the return-value of the onFailure-callback on failure**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * const value = result.getOrElse((error) => 4);\n   * ```\n   */\n  getOrElse(onFailure: (error: ErrorType) => OkType): OkType;\n  getOrElse(onFailure: (error: ErrorType) => Promise<OkType>): Promise<OkType>;\n\n  /**\n   * **Returns the value on success or throws the error on failure**\n   *\n   * Example:\n   * ```tsx\n   * const result = doStuff();\n   * const value = result.getOrThrow();\n   * ```\n   */\n  getOrThrow(): OkType;\n\n  /**\n   * **Maps a result to another result**\n   * If the result is success, it will call the callback-function with the encapsulated value, which returns another Result.\n   * Nested Results are supported, which will basically act as a flat-map.\n   * If the result is failure, it will ignore the callback-function.\n   *\n   * Example:\n   * ```tsx\n   *\n   * class ErrorA extends Error {}\n   * class ErrorB extends Error {}\n   *\n   * function doA(): Result<ErrorA, number> {\n   *  // ...\n   * }\n   *\n   * function doB(value: number): Result<ErrorB, string> {\n   *  // ...\n   * }\n   *\n   * // nested results will flat-map to a single Result...\n   * const result1 = doA().map(value => doB(value)); // Result<ErrorA | ErrorB, string>\n   *\n   * // ...or transform the successful value right away\n   * // note: underneath, the callback is wrapped inside Result.safe() in case the callback\n   * // might throw\n   * const result2 = doA().map(value => value * 2); // Result<ErrorA | Error, number>\n   * ```\n   */\n  map<T>(\n    fn: (value: OkType) => Promise<T>\n  ): Promise<\n    JoinErrorTypes<\n      ErrorType,\n      T extends Result<any, any, any> ? T : Result<Error, T, any>\n    >\n  >;\n  map<T>(\n    fn: (value: OkType) => T\n  ): JoinErrorTypes<\n    ErrorType,\n    T extends Result<any, any, any> ? T : Result<Error, T, any>\n  >;\n\n  /**\n   * **Rolls back things that were successful**\n   * This method is especially useful when working with Result.combine()\n   */\n  rollback(): Result<Error, void> | Promise<Result<Error, void>>;\n}\n\ntype InferErrorType<T extends Result<any, any, any>> = T extends Result<\n  infer Errortype,\n  any,\n  any\n>\n  ? Errortype\n  : never;\n\ntype InferOkType<T extends Result<any, any, any>> = T extends Result<\n  any,\n  infer OkType,\n  any\n>\n  ? OkType\n  : never;\n\ntype JoinErrorTypes<ErrorType, B extends Result<any, any, any>> = Result<\n  ErrorType | InferErrorType<B>,\n  InferOkType<B>,\n  any\n>;\n\ntype ExtractErrorTypes<Tuple extends any[]> = {\n  [Index in keyof Tuple]: Tuple[Index] extends Result<any, any, any>\n    ? InferErrorType<Tuple[Index]>\n    : never;\n}[number];\n\ntype MapResultTupleToOkTypeTuple<Tuple extends any[]> = {\n  [Index in keyof Tuple]: Tuple[Index] extends Result<any, any, any>\n    ? InferOkType<Tuple[Index]>\n    : never;\n};\n\ntype RollbackFunction = (() => void) | (() => Promise<void>);\n\ntype HasAsyncRollbackFunction<T extends any[]> = {\n  [Index in keyof T]: T[Index] extends () => Promise<infer U> | infer U\n    ? U extends Result<any, any, () => Promise<void>>\n      ? true\n      : false\n    : false;\n}[number] extends false\n  ? false\n  : true;\n\ntype UnwrapThunks<T extends any[]> = {\n  [Index in keyof T]: T[Index] extends () => Promise<infer U>\n    ? U\n    : T[Index] extends () => infer U\n    ? U\n    : T[Index];\n};\n\ntype HasAsyncThunk<T extends any[]> = {\n  [Index in keyof T]: T[Index] extends () => Promise<any> ? true : false;\n}[number] extends false\n  ? false\n  : true;\n\ntype PromiseReturnType<T extends (...args: any) => any> = T extends (\n  ...args: any\n) => Promise<infer U>\n  ? U\n  : never;\n\n/**\n * Creation functions of Result-type\n */\n\nexport namespace Result {\n  /**\n   * **Returns a Result.Ok which contains a encapsulated value**\n   *\n   * Example:\n   * ```tsx\n   * const result = Result.ok(12); // Result<unknown, number>\n   * ```\n   */\n  export function ok<\n    ErrorType extends unknown,\n    OkType,\n    RollbackFn extends RollbackFunction = any\n  >(\n    value?: OkType,\n    rollbackFn?: RollbackFn\n  ): Result<ErrorType, OkType, RollbackFn> {\n    // if (value === null) {\n    //   throw new Error(\n    //     `Expected thruthy valid value as parameter but instead received: null`\n    //   );\n    // }\n\n    return new Ok<ErrorType, OkType, RollbackFn>(\n      value || null!,\n      rollbackFn\n    ) as any;\n  }\n\n  /**\n   * **Returns a Result.Error which contains a encapsulated error**\n   *\n   * Example:\n   * ```tsx\n   * const result = Result.error(new Error(\"Something went wrong!\")); // Result<Error, unknown>\n   * ```\n   */\n  export function error<\n    ErrorType extends unknown,\n    OkType extends unknown,\n    RollbackFn extends RollbackFunction = any\n  >(\n    error: ErrorType,\n    rollbackFn?: RollbackFn\n  ): Result<ErrorType, OkType, RollbackFn> {\n    return new Err<ErrorType, OkType, RollbackFn>(error, rollbackFn);\n  }\n\n  type SafeReturnType<E, T> = T extends Result<any, any, any>\n    ? Result<E | InferErrorType<T>, InferOkType<T>, never>\n    : Result<E, T, never>;\n\n  /**\n   * **Functions as a try-catch, returning the return-value of the callback on success, or the predefined error or caught error on failure **\n   *\n   * Example:\n   * ```tsx\n   * // with caught error...\n   * const result = Result.safe(() => {\n   *   let value = 2;\n   *\n   *   // code that might throw...\n   *\n   *   return value;\n   * }); // Result<Error, number>\n   *\n   * // with predefined error...\n   * class CustomError extends Error {}\n   *\n   * const result = Result.safe(new CustomError(\"Custom error!\"), () => {\n   *   let value = 2;\n   *\n   *   // code that might throw...\n   *\n   *   return value;\n   * }); // Result<CustomError, number>\n   *\n   * // with predefined error Class...\n   * const result = Result.safe(CustomError, () => {\n   *   let value = 2;\n   *\n   *   // code that might throw...\n   *\n   *   return value;\n   * }); // Result<CustomError, number>\n   * ```\n   */\n  export function safe<T>(\n    fn: () => Promise<T>\n  ): Promise<SafeReturnType<Error, T>>;\n  export function safe<T>(fn: () => T): SafeReturnType<Error, T>;\n  export function safe<ErrorType, T>(\n    err: ErrorType | (new (...args: any[]) => ErrorType),\n    fn: () => Promise<T>\n  ): Promise<SafeReturnType<ErrorType, T>>;\n  export function safe<ErrorType, T>(\n    err: ErrorType | (new (...args: any[]) => ErrorType),\n    fn: () => T\n  ): SafeReturnType<ErrorType, T>;\n  export function safe(errOrFn: any, fn?: any) {\n    const hasCustomError = fn !== undefined;\n\n    const execute = hasCustomError ? fn : errOrFn;\n\n    function getError(caughtError: Error) {\n      if (!hasCustomError) {\n        // just forward the original Error\n        return caughtError;\n      }\n\n      // pass the caught error to the specified constructor\n      if (typeof errOrFn === \"function\") {\n        return new errOrFn(caughtError);\n      }\n\n      // return predefined error\n      return errOrFn;\n    }\n\n    try {\n      const resultOrPromise = execute();\n\n      if (resultOrPromise instanceof Promise) {\n        return resultOrPromise\n          .then(okValue => {\n            return isResult(okValue) ? okValue : Result.ok(okValue);\n          })\n          .catch(caughtError => error(getError(caughtError)));\n      }\n\n      return isResult(resultOrPromise)\n        ? resultOrPromise\n        : Result.ok(resultOrPromise);\n    } catch (caughtError) {\n      return error(getError(caughtError));\n    }\n  }\n\n  type CombineResult<\n    T extends (unknown | (() => unknown) | (() => Promise<unknown>))[]\n  > = Result<\n    ExtractErrorTypes<UnwrapThunks<T>>,\n    MapResultTupleToOkTypeTuple<UnwrapThunks<T>>,\n    HasAsyncRollbackFunction<T> extends true ? () => Promise<void> : () => void\n  >;\n\n  /**\n   * **Accepts multiple Results or functions that return Results and returns a singe Result**\n   * Successful values will be placed inside a tuple.\n   *\n   * Example:\n   * ```tsx\n   *\n   * function doA(): Result<Error, string> {}\n   * function doB(value: number): Result<Error, number> {}\n   * function doC(value: string): Result<Error, Date> {}\n   *\n   * const result = Result.combine(\n   *   doA(),\n   *   () => doB(2),\n   *   () => doC(\"hello\")\n   * ); // Result<Error, [string, number, Date]>\n   *\n   * if (result.isSuccess()) {\n   *   result.value; // [string, number, Date]\n   * }\n   * ```\n   */\n\n  export function combine<\n    T extends (unknown | (() => unknown) | (() => Promise<unknown>))[]\n  >(\n    ...items: T\n  ): HasAsyncThunk<T> extends true\n    ? Promise<CombineResult<T>>\n    : CombineResult<T> {\n    if (!items.length) {\n      throw new Error(\"Expected at least 1 argument\");\n    }\n\n    const values: unknown[] = [];\n    const rollbacks: RollbackFunction[] = [];\n    let error: Err<unknown, unknown, any> | null = null;\n\n    function rollback() {\n      const reversedRollbacks = rollbacks.reverse();\n      const wrappedRollbackFns = reversedRollbacks.map(fn => Result.wrap(fn));\n\n      let error: Err<unknown, unknown, any> | null = null;\n\n      return forEachValueThunkOrPromise(\n        wrappedRollbackFns,\n        (result: Result<unknown, unknown>) => {\n          if (result.isFailure()) {\n            error = Result.error<unknown, unknown, any>(result.error) as any;\n            return false;\n          }\n\n          return true;\n        },\n        () => error || ok()\n      );\n    }\n\n    return forEachValueThunkOrPromise(\n      items,\n      (result: Result<unknown, unknown>) => {\n        if (result.isFailure()) {\n          error = Result.error<unknown, unknown>(result.error, rollback) as any;\n          return false;\n        }\n\n        values.push(result.value);\n        rollbacks.push(() => result.rollback());\n        return true;\n      },\n      () => error || ok(values, rollback)\n    );\n  }\n\n  /**\n   * **Transforms an existing function into a function that returns a Result**\n   *\n   * Example:\n   * ```tsx\n   * function add2(value: number) {\n   *  // code that might throw....\n   *\n   *  return value + 2;\n   * }\n   *\n   * const wrappedAdd2 = Result.wrap(add2);\n   *\n   * const result1 = add2(4) // number;\n   * const result2 = wrappedAdd2(4) // Result<Error, number>;\n   * ```\n   */\n\n  export function wrap<Fn extends (...args: any) => Promise<any>>(\n    fn: Fn\n  ): (\n    ...args: Parameters<Fn>\n  ) => Promise<Result<Error, PromiseReturnType<Fn>, never>>;\n  export function wrap<Fn extends (...args: any) => any>(\n    fn: Fn\n  ): (...args: Parameters<Fn>) => Result<Error, ReturnType<Fn>, never>;\n  export function wrap(fn: any) {\n    return function wrapped(...args: any) {\n      try {\n        const resultOrPromise = fn(...args);\n\n        if (resultOrPromise instanceof Promise) {\n          return resultOrPromise\n            .then(okValue => Result.ok(okValue))\n            .catch(err => error(err));\n        }\n\n        return ok(resultOrPromise);\n      } catch (err) {\n        return error(err);\n      }\n    };\n  }\n}\n\n/**\n * Underlying Result types\n */\n\nabstract class Base<\n  ErrorType extends unknown,\n  OkType extends unknown,\n  RollbackFn extends RollbackFunction\n> implements IResult<ErrorType, OkType> {\n  constructor(protected readonly rollbackFn?: RollbackFn) {}\n\n  errorOrNull(): ErrorType | null {\n    if (this.isSuccess()) {\n      return null;\n    }\n\n    return (this as any).error as ErrorType;\n  }\n\n  getOrNull(): OkType | null {\n    if (this.isFailure()) {\n      return null;\n    }\n\n    return (this as any).value as OkType;\n  }\n\n  toString(): string {\n    throw new Error(\"Method not implemented.\");\n  }\n  inspect(): string {\n    return this.toString();\n  }\n\n  fold<R>(\n    onSuccess: (value: OkType) => R,\n    onFailure: (error: ErrorType) => R\n  ): R;\n  fold<R>(\n    onSuccess: (value: OkType) => Promise<R>,\n    onFailure: (error: ErrorType) => Promise<R>\n  ): Promise<R>;\n  fold(onSuccess: any, onFailure: any) {\n    if (this.isFailure()) {\n      return onFailure(this.error);\n    }\n\n    return onSuccess((this as any).value as OkType);\n  }\n\n  getOrDefault(defaultValue: OkType): OkType {\n    if (this.isSuccess()) {\n      return this.value;\n    }\n\n    return defaultValue;\n  }\n\n  getOrElse(onFailure: (error: ErrorType) => OkType): OkType;\n  getOrElse(onFailure: (error: ErrorType) => Promise<OkType>): Promise<OkType>;\n  getOrElse(onFailure: any) {\n    if (this.isSuccess()) {\n      return isAsyncFn(onFailure) ? Promise.resolve(this.value) : this.value;\n    }\n\n    return onFailure((this as any).error as ErrorType);\n  }\n\n  getOrThrow(): OkType {\n    if (this.isFailure()) {\n      throw this.error;\n    }\n\n    return (this as any).value as OkType;\n  }\n\n  isSuccess(): this is Ok<ErrorType, OkType, RollbackFn> {\n    throw new Error(\"Method not implemented.\");\n  }\n  isFailure(): this is Err<ErrorType, OkType, RollbackFn> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  map<T>(\n    fn: (value: OkType) => Promise<T>\n  ): Promise<\n    JoinErrorTypes<\n      ErrorType,\n      T extends Result<any, any, any> ? T : Result<Error, T, any>\n    >\n  >;\n  map<T>(\n    fn: (value: OkType) => T\n  ): JoinErrorTypes<\n    ErrorType,\n    T extends Result<any, any, any> ? T : Result<Error, T, any>\n  >;\n  map(fn: any) {\n    if (this.isFailure()) {\n      return isAsyncFn(fn) ? Promise.resolve(this) : this;\n    }\n\n    const result = Result.safe(() => fn((this as any).value) as any);\n\n    return result as any;\n  }\n\n  rollback(): RollbackFn extends RollbackFunction\n    ? RollbackFn extends () => Promise<void>\n      ? Promise<Result<Error, void>>\n      : Result<Error, void>\n    : void {\n    if (this.rollbackFn) {\n      return this.rollbackFn() as any;\n    }\n\n    return null as any;\n  }\n}\n\nclass Ok<\n  ErrorType extends unknown,\n  OkType extends unknown,\n  RollbackFn extends RollbackFunction\n> extends Base<ErrorType, OkType, RollbackFn> {\n  public readonly value: OkType;\n\n  constructor(val: OkType, rollbackFn?: RollbackFn) {\n    super(rollbackFn);\n    this.value = val;\n  }\n\n  isSuccess(): this is Ok<ErrorType, OkType, RollbackFn> {\n    return true;\n  }\n\n  isFailure(): this is Err<ErrorType, OkType, RollbackFn> {\n    return false;\n  }\n\n  toString(): string {\n    return `Result.Ok(${this.value})`;\n  }\n\n  /**\n   * **Creates and forwards a brand new Result out of the current error or value **\n   */\n  forward(): Result<any, OkType, RollbackFn> {\n    return Result.ok(this.value);\n  }\n}\n\nclass Err<\n  ErrorType extends unknown,\n  OkType extends unknown,\n  RollbackFn extends RollbackFunction\n> extends Base<ErrorType, OkType, RollbackFn> {\n  public readonly error: ErrorType;\n\n  constructor(err: ErrorType, rollbackFn?: RollbackFn) {\n    super(rollbackFn);\n    this.error = err;\n  }\n\n  isSuccess(): this is Ok<ErrorType, OkType, RollbackFn> {\n    return false;\n  }\n\n  isFailure(): this is Err<ErrorType, OkType, RollbackFn> {\n    return true;\n  }\n\n  toString(): string {\n    return `Result.Error(${this.error})`;\n  }\n\n  /**\n   * **Creates and forwards a brand new Result out of the current error or value **\n   */\n  forward(): Result<ErrorType, any, RollbackFn> {\n    return Result.error(this.error);\n  }\n}\n"],"names":["isAsyncFn","fn","constructor","name","isResult","value","Ok","Err","forEachValueThunkOrPromise","items","execFn","foldFn","shouldBreak","result","reduce","prev","valueOrThunk","then","run","valueOrPromise","Promise","syncThenable","isSync","cb","Result","ok","rollbackFn","error","errOrFn","hasCustomError","undefined","execute","getError","caughtError","resultOrPromise","okValue","length","Error","values","rollbacks","rollback","wrappedRollbackFns","reverse","map","wrap","isFailure","push","err","Base","errorOrNull","this","isSuccess","getOrNull","toString","inspect","fold","onSuccess","onFailure","getOrDefault","defaultValue","getOrElse","resolve","getOrThrow","safe","_this","val","forward"],"mappings":"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"}