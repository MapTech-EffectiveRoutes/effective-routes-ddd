/**
 * Util
 */
/**
 * Types
 */
export declare type Result<ErrorType, OkType, RollbackFn extends RollbackFunction = any> = Ok<ErrorType, OkType, RollbackFn> | Err<ErrorType, OkType, RollbackFn>;
interface IResult<ErrorType, OkType> {
    /**
     * **Indicates whether the Result is of type Ok**
     *
     * Example:
     * ```tsx
     * const result = doStuff();
     * if (result.isSuccess()) {
     *   result.value; // we now have access to 'value'
     * } else {
     *   result.error; // we now have access to 'error'
     * }
     * ```
     */
    isSuccess(): this is Ok<ErrorType, OkType, any>;
    /**
     * **Indicates whether the Result is of type Error**
     *
     * Example:
     * ```tsx
     * const result = doStuff();
     * if (result.isFailure()) {
     *   result.error; // we now have access to 'error'
     * } else {
     *   result.value; // we now have access to 'value'
     * }
     * ```
     */
    isFailure(): this is Err<ErrorType, OkType, any>;
    /**
     * **Returns the error on failure or null on success**
     *
     * Example:
     * ```tsx
     * // on failure...
     * const result = thisWillFail();
     * const error = result.errorOrNull(); // error is defined
     *
     * // on success...
     * const result = thisWillSucceed();
     * const error = result.errorOrNull(); // error is null
     * ```
     */
    errorOrNull(): ErrorType | null;
    /**
     * **Returns the value on success or null on failure**
     *
     * Example:
     * ```tsx
     * // on success...
     * const result = thisWillSucceed();
     * const value = result.getOrNull(); // value is defined
     *
     * // on failure...
     * const result = thisWillFail();
     * const value = result.getOrNull(); // value is null
     * ```
     */
    getOrNull(): OkType | null;
    /**
     * **Returns a visual representation of the inner value**
     *
     * Example:
     * ```tsx
     * const result = doStuff();
     * const display = result.toString() // 'Result.Ok("value")' | 'Result.Error("error-message")'
     * ```
     */
    toString(): string;
    /**
     * **See Result.toString()**
     */
    inspect(): string;
    /**
     * **Returns the result of the onSuccess-callback for the encapsulated value if this instance represents success or the result of onFailure-callback for the encapsulated error if it is failure.**
     *
     * Example:
     * ```tsx
     * const result = doStuff();
     * const value = result.fold(
     *    // on success...
     *    (value) => value * 2,
     *     // on failure...
     *    (error) => 4
     * );
     * ```
     */
    fold<R>(onSuccess: (value: OkType) => R, onFailure: (error: ErrorType) => R): R;
    fold<R>(onSuccess: (value: OkType) => Promise<R>, onFailure: (error: ErrorType) => Promise<R>): Promise<R>;
    /**
     * **Returns the value on success or a default value on failure**
     *
     * Example:
     * ```tsx
     * const result = doStuff();
     * const value = result.getOrDefault(2);
     * ```
     */
    getOrDefault(defaultValue: OkType): OkType;
    /**
     * **Returns the value on success or the return-value of the onFailure-callback on failure**
     *
     * Example:
     * ```tsx
     * const result = doStuff();
     * const value = result.getOrElse((error) => 4);
     * ```
     */
    getOrElse(onFailure: (error: ErrorType) => OkType): OkType;
    getOrElse(onFailure: (error: ErrorType) => Promise<OkType>): Promise<OkType>;
    /**
     * **Returns the value on success or throws the error on failure**
     *
     * Example:
     * ```tsx
     * const result = doStuff();
     * const value = result.getOrThrow();
     * ```
     */
    getOrThrow(): OkType;
    /**
     * **Maps a result to another result**
     * If the result is success, it will call the callback-function with the encapsulated value, which returns another Result.
     * Nested Results are supported, which will basically act as a flat-map.
     * If the result is failure, it will ignore the callback-function.
     *
     * Example:
     * ```tsx
     *
     * class ErrorA extends Error {}
     * class ErrorB extends Error {}
     *
     * function doA(): Result<ErrorA, number> {
     *  // ...
     * }
     *
     * function doB(value: number): Result<ErrorB, string> {
     *  // ...
     * }
     *
     * // nested results will flat-map to a single Result...
     * const result1 = doA().map(value => doB(value)); // Result<ErrorA | ErrorB, string>
     *
     * // ...or transform the successful value right away
     * // note: underneath, the callback is wrapped inside Result.safe() in case the callback
     * // might throw
     * const result2 = doA().map(value => value * 2); // Result<ErrorA | Error, number>
     * ```
     */
    map<T>(fn: (value: OkType) => Promise<T>): Promise<JoinErrorTypes<ErrorType, T extends Result<any, any, any> ? T : Result<Error, T, any>>>;
    map<T>(fn: (value: OkType) => T): JoinErrorTypes<ErrorType, T extends Result<any, any, any> ? T : Result<Error, T, any>>;
    /**
     * **Rolls back things that were successful**
     * This method is especially useful when working with Result.combine()
     */
    rollback(): Result<Error, void> | Promise<Result<Error, void>>;
}
declare type InferErrorType<T extends Result<any, any, any>> = T extends Result<infer Errortype, any, any> ? Errortype : never;
declare type InferOkType<T extends Result<any, any, any>> = T extends Result<any, infer OkType, any> ? OkType : never;
declare type JoinErrorTypes<ErrorType, B extends Result<any, any, any>> = Result<ErrorType | InferErrorType<B>, InferOkType<B>, any>;
declare type ExtractErrorTypes<Tuple extends any[]> = {
    [Index in keyof Tuple]: Tuple[Index] extends Result<any, any, any> ? InferErrorType<Tuple[Index]> : never;
}[number];
declare type MapResultTupleToOkTypeTuple<Tuple extends any[]> = {
    [Index in keyof Tuple]: Tuple[Index] extends Result<any, any, any> ? InferOkType<Tuple[Index]> : never;
};
declare type RollbackFunction = (() => void) | (() => Promise<void>);
declare type HasAsyncRollbackFunction<T extends any[]> = {
    [Index in keyof T]: T[Index] extends () => Promise<infer U> | infer U ? U extends Result<any, any, () => Promise<void>> ? true : false : false;
}[number] extends false ? false : true;
declare type UnwrapThunks<T extends any[]> = {
    [Index in keyof T]: T[Index] extends () => Promise<infer U> ? U : T[Index] extends () => infer U ? U : T[Index];
};
declare type HasAsyncThunk<T extends any[]> = {
    [Index in keyof T]: T[Index] extends () => Promise<any> ? true : false;
}[number] extends false ? false : true;
declare type PromiseReturnType<T extends (...args: any) => any> = T extends (...args: any) => Promise<infer U> ? U : never;
/**
 * Creation functions of Result-type
 */
export declare namespace Result {
    /**
     * **Returns a Result.Ok which contains a encapsulated value**
     *
     * Example:
     * ```tsx
     * const result = Result.ok(12); // Result<unknown, number>
     * ```
     */
    export function ok<ErrorType extends unknown, OkType, RollbackFn extends RollbackFunction = any>(value?: OkType, rollbackFn?: RollbackFn): Result<ErrorType, OkType, RollbackFn>;
    /**
     * **Returns a Result.Error which contains a encapsulated error**
     *
     * Example:
     * ```tsx
     * const result = Result.error(new Error("Something went wrong!")); // Result<Error, unknown>
     * ```
     */
    export function error<ErrorType extends unknown, OkType extends unknown, RollbackFn extends RollbackFunction = any>(error: ErrorType, rollbackFn?: RollbackFn): Result<ErrorType, OkType, RollbackFn>;
    type SafeReturnType<E, T> = T extends Result<any, any, any> ? Result<E | InferErrorType<T>, InferOkType<T>, never> : Result<E, T, never>;
    /**
     * **Functions as a try-catch, returning the return-value of the callback on success, or the predefined error or caught error on failure **
     *
     * Example:
     * ```tsx
     * // with caught error...
     * const result = Result.safe(() => {
     *   let value = 2;
     *
     *   // code that might throw...
     *
     *   return value;
     * }); // Result<Error, number>
     *
     * // with predefined error...
     * class CustomError extends Error {}
     *
     * const result = Result.safe(new CustomError("Custom error!"), () => {
     *   let value = 2;
     *
     *   // code that might throw...
     *
     *   return value;
     * }); // Result<CustomError, number>
     *
     * // with predefined error Class...
     * const result = Result.safe(CustomError, () => {
     *   let value = 2;
     *
     *   // code that might throw...
     *
     *   return value;
     * }); // Result<CustomError, number>
     * ```
     */
    export function safe<T>(fn: () => Promise<T>): Promise<SafeReturnType<Error, T>>;
    export function safe<T>(fn: () => T): SafeReturnType<Error, T>;
    export function safe<ErrorType, T>(err: ErrorType | (new (...args: any[]) => ErrorType), fn: () => Promise<T>): Promise<SafeReturnType<ErrorType, T>>;
    export function safe<ErrorType, T>(err: ErrorType | (new (...args: any[]) => ErrorType), fn: () => T): SafeReturnType<ErrorType, T>;
    type CombineResult<T extends (unknown | (() => unknown) | (() => Promise<unknown>))[]> = Result<ExtractErrorTypes<UnwrapThunks<T>>, MapResultTupleToOkTypeTuple<UnwrapThunks<T>>, HasAsyncRollbackFunction<T> extends true ? () => Promise<void> : () => void>;
    /**
     * **Accepts multiple Results or functions that return Results and returns a singe Result**
     * Successful values will be placed inside a tuple.
     *
     * Example:
     * ```tsx
     *
     * function doA(): Result<Error, string> {}
     * function doB(value: number): Result<Error, number> {}
     * function doC(value: string): Result<Error, Date> {}
     *
     * const result = Result.combine(
     *   doA(),
     *   () => doB(2),
     *   () => doC("hello")
     * ); // Result<Error, [string, number, Date]>
     *
     * if (result.isSuccess()) {
     *   result.value; // [string, number, Date]
     * }
     * ```
     */
    export function combine<T extends (unknown | (() => unknown) | (() => Promise<unknown>))[]>(...items: T): HasAsyncThunk<T> extends true ? Promise<CombineResult<T>> : CombineResult<T>;
    /**
     * **Transforms an existing function into a function that returns a Result**
     *
     * Example:
     * ```tsx
     * function add2(value: number) {
     *  // code that might throw....
     *
     *  return value + 2;
     * }
     *
     * const wrappedAdd2 = Result.wrap(add2);
     *
     * const result1 = add2(4) // number;
     * const result2 = wrappedAdd2(4) // Result<Error, number>;
     * ```
     */
    export function wrap<Fn extends (...args: any) => Promise<any>>(fn: Fn): (...args: Parameters<Fn>) => Promise<Result<Error, PromiseReturnType<Fn>, never>>;
    export function wrap<Fn extends (...args: any) => any>(fn: Fn): (...args: Parameters<Fn>) => Result<Error, ReturnType<Fn>, never>;
    export {};
}
/**
 * Underlying Result types
 */
declare abstract class Base<ErrorType extends unknown, OkType extends unknown, RollbackFn extends RollbackFunction> implements IResult<ErrorType, OkType> {
    protected readonly rollbackFn?: RollbackFn | undefined;
    constructor(rollbackFn?: RollbackFn | undefined);
    errorOrNull(): ErrorType | null;
    getOrNull(): OkType | null;
    toString(): string;
    inspect(): string;
    fold<R>(onSuccess: (value: OkType) => R, onFailure: (error: ErrorType) => R): R;
    fold<R>(onSuccess: (value: OkType) => Promise<R>, onFailure: (error: ErrorType) => Promise<R>): Promise<R>;
    getOrDefault(defaultValue: OkType): OkType;
    getOrElse(onFailure: (error: ErrorType) => OkType): OkType;
    getOrElse(onFailure: (error: ErrorType) => Promise<OkType>): Promise<OkType>;
    getOrThrow(): OkType;
    isSuccess(): this is Ok<ErrorType, OkType, RollbackFn>;
    isFailure(): this is Err<ErrorType, OkType, RollbackFn>;
    map<T>(fn: (value: OkType) => Promise<T>): Promise<JoinErrorTypes<ErrorType, T extends Result<any, any, any> ? T : Result<Error, T, any>>>;
    map<T>(fn: (value: OkType) => T): JoinErrorTypes<ErrorType, T extends Result<any, any, any> ? T : Result<Error, T, any>>;
    rollback(): RollbackFn extends RollbackFunction ? RollbackFn extends () => Promise<void> ? Promise<Result<Error, void>> : Result<Error, void> : void;
}
declare class Ok<ErrorType extends unknown, OkType extends unknown, RollbackFn extends RollbackFunction> extends Base<ErrorType, OkType, RollbackFn> {
    readonly value: OkType;
    constructor(val: OkType, rollbackFn?: RollbackFn);
    isSuccess(): this is Ok<ErrorType, OkType, RollbackFn>;
    isFailure(): this is Err<ErrorType, OkType, RollbackFn>;
    toString(): string;
    /**
     * **Creates and forwards a brand new Result out of the current error or value **
     */
    forward(): Result<any, OkType, RollbackFn>;
}
declare class Err<ErrorType extends unknown, OkType extends unknown, RollbackFn extends RollbackFunction> extends Base<ErrorType, OkType, RollbackFn> {
    readonly error: ErrorType;
    constructor(err: ErrorType, rollbackFn?: RollbackFn);
    isSuccess(): this is Ok<ErrorType, OkType, RollbackFn>;
    isFailure(): this is Err<ErrorType, OkType, RollbackFn>;
    toString(): string;
    /**
     * **Creates and forwards a brand new Result out of the current error or value **
     */
    forward(): Result<ErrorType, any, RollbackFn>;
}
export {};
