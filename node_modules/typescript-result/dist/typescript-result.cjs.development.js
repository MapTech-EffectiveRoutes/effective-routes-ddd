'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

/**
 * Util
 */
function isAsyncFn(fn) {
  return fn.constructor.name === "AsyncFunction";
}

function isResult(value) {
  return value instanceof Ok || value instanceof Err;
} // Utility to emulate a Promise, but where 'then' is initially sync, unless the callback
// returns a real Promise
// This utility function is mainly used within Result.combine in order to loop over callbacks
// that may be sync or async -> we only want to return a Promise when we absolutely need to


function syncThenable() {
  function then(cb) {
    var result = cb();

    if (result instanceof Promise) {
      return result;
    }

    return syncThenable();
  }

  return {
    isSync: true,
    then: then
  };
} // utility fn to loop over (async) callbacks or values


function forEachValueThunkOrPromise(items, execFn, // false means error, true means success here
foldFn) {
  // we want to break the iteration when an error ocurred
  var shouldBreak = false;
  var result = items.reduce(function (prev, valueOrThunk) {
    return prev.then(function () {
      // if an error ocurred, return early
      if (shouldBreak) {
        return null;
      }

      function run(value) {
        var isSuccess = execFn(value);

        if (!isSuccess) {
          shouldBreak = true;
        }
      } // if the current item is a function -> run it


      var valueOrPromise = typeof valueOrThunk === "function" ? valueOrThunk() : valueOrThunk; // if the 'unpacked' item is an actual Promise...

      if (valueOrPromise instanceof Promise) {
        return valueOrPromise.then(run);
      } // Apparently we're dealing with sync stuff...


      return run(valueOrPromise);
    });
  }, syncThenable());

  if (result.isSync) {
    return foldFn();
  }

  return result.then(function () {
    return foldFn();
  });
}

(function (Result) {
  /**
   * **Returns a Result.Ok which contains a encapsulated value**
   *
   * Example:
   * ```tsx
   * const result = Result.ok(12); // Result<unknown, number>
   * ```
   */
  function ok(value, rollbackFn) {
    // if (value === null) {
    //   throw new Error(
    //     `Expected thruthy valid value as parameter but instead received: null`
    //   );
    // }
    return new Ok(value || null, rollbackFn);
  }

  Result.ok = ok;
  /**
   * **Returns a Result.Error which contains a encapsulated error**
   *
   * Example:
   * ```tsx
   * const result = Result.error(new Error("Something went wrong!")); // Result<Error, unknown>
   * ```
   */

  function error(error, rollbackFn) {
    return new Err(error, rollbackFn);
  }

  Result.error = error;

  function safe(errOrFn, fn) {
    var hasCustomError = fn !== undefined;
    var execute = hasCustomError ? fn : errOrFn;

    function getError(caughtError) {
      if (!hasCustomError) {
        // just forward the original Error
        return caughtError;
      } // pass the caught error to the specified constructor


      if (typeof errOrFn === "function") {
        return new errOrFn(caughtError);
      } // return predefined error


      return errOrFn;
    }

    try {
      var resultOrPromise = execute();

      if (resultOrPromise instanceof Promise) {
        return resultOrPromise.then(function (okValue) {
          return isResult(okValue) ? okValue : Result.ok(okValue);
        })["catch"](function (caughtError) {
          return error(getError(caughtError));
        });
      }

      return isResult(resultOrPromise) ? resultOrPromise : Result.ok(resultOrPromise);
    } catch (caughtError) {
      return error(getError(caughtError));
    }
  }

  Result.safe = safe;
  /**
   * **Accepts multiple Results or functions that return Results and returns a singe Result**
   * Successful values will be placed inside a tuple.
   *
   * Example:
   * ```tsx
   *
   * function doA(): Result<Error, string> {}
   * function doB(value: number): Result<Error, number> {}
   * function doC(value: string): Result<Error, Date> {}
   *
   * const result = Result.combine(
   *   doA(),
   *   () => doB(2),
   *   () => doC("hello")
   * ); // Result<Error, [string, number, Date]>
   *
   * if (result.isSuccess()) {
   *   result.value; // [string, number, Date]
   * }
   * ```
   */

  function combine() {
    for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
      items[_key] = arguments[_key];
    }

    if (!items.length) {
      throw new Error("Expected at least 1 argument");
    }

    var values = [];
    var rollbacks = [];
    var error = null;

    function rollback() {
      var reversedRollbacks = rollbacks.reverse();
      var wrappedRollbackFns = reversedRollbacks.map(function (fn) {
        return Result.wrap(fn);
      });
      var error = null;
      return forEachValueThunkOrPromise(wrappedRollbackFns, function (result) {
        if (result.isFailure()) {
          error = Result.error(result.error);
          return false;
        }

        return true;
      }, function () {
        return error || ok();
      });
    }

    return forEachValueThunkOrPromise(items, function (result) {
      if (result.isFailure()) {
        error = Result.error(result.error, rollback);
        return false;
      }

      values.push(result.value);
      rollbacks.push(function () {
        return result.rollback();
      });
      return true;
    }, function () {
      return error || ok(values, rollback);
    });
  }

  Result.combine = combine;

  function wrap(fn) {
    return function wrapped() {
      try {
        var resultOrPromise = fn.apply(void 0, arguments);

        if (resultOrPromise instanceof Promise) {
          return resultOrPromise.then(function (okValue) {
            return Result.ok(okValue);
          })["catch"](function (err) {
            return error(err);
          });
        }

        return ok(resultOrPromise);
      } catch (err) {
        return error(err);
      }
    };
  }

  Result.wrap = wrap;
})(exports.Result || (exports.Result = {}));
/**
 * Underlying Result types
 */


var Base = /*#__PURE__*/function () {
  function Base(rollbackFn) {
    this.rollbackFn = rollbackFn;
  }

  var _proto = Base.prototype;

  _proto.errorOrNull = function errorOrNull() {
    if (this.isSuccess()) {
      return null;
    }

    return this.error;
  };

  _proto.getOrNull = function getOrNull() {
    if (this.isFailure()) {
      return null;
    }

    return this.value;
  };

  _proto.toString = function toString() {
    throw new Error("Method not implemented.");
  };

  _proto.inspect = function inspect() {
    return this.toString();
  };

  _proto.fold = function fold(onSuccess, onFailure) {
    if (this.isFailure()) {
      return onFailure(this.error);
    }

    return onSuccess(this.value);
  };

  _proto.getOrDefault = function getOrDefault(defaultValue) {
    if (this.isSuccess()) {
      return this.value;
    }

    return defaultValue;
  };

  _proto.getOrElse = function getOrElse(onFailure) {
    if (this.isSuccess()) {
      return isAsyncFn(onFailure) ? Promise.resolve(this.value) : this.value;
    }

    return onFailure(this.error);
  };

  _proto.getOrThrow = function getOrThrow() {
    if (this.isFailure()) {
      throw this.error;
    }

    return this.value;
  };

  _proto.isSuccess = function isSuccess() {
    throw new Error("Method not implemented.");
  };

  _proto.isFailure = function isFailure() {
    throw new Error("Method not implemented.");
  };

  _proto.map = function map(fn) {
    var _this = this;

    if (this.isFailure()) {
      return isAsyncFn(fn) ? Promise.resolve(this) : this;
    }

    var result = exports.Result.safe(function () {
      return fn(_this.value);
    });
    return result;
  };

  _proto.rollback = function rollback() {
    if (this.rollbackFn) {
      return this.rollbackFn();
    }

    return null;
  };

  return Base;
}();

var Ok = /*#__PURE__*/function (_Base) {
  _inheritsLoose(Ok, _Base);

  function Ok(val, rollbackFn) {
    var _this2;

    _this2 = _Base.call(this, rollbackFn) || this;
    _this2.value = val;
    return _this2;
  }

  var _proto2 = Ok.prototype;

  _proto2.isSuccess = function isSuccess() {
    return true;
  };

  _proto2.isFailure = function isFailure() {
    return false;
  };

  _proto2.toString = function toString() {
    return "Result.Ok(" + this.value + ")";
  }
  /**
   * **Creates and forwards a brand new Result out of the current error or value **
   */
  ;

  _proto2.forward = function forward() {
    return exports.Result.ok(this.value);
  };

  return Ok;
}(Base);

var Err = /*#__PURE__*/function (_Base2) {
  _inheritsLoose(Err, _Base2);

  function Err(err, rollbackFn) {
    var _this3;

    _this3 = _Base2.call(this, rollbackFn) || this;
    _this3.error = err;
    return _this3;
  }

  var _proto3 = Err.prototype;

  _proto3.isSuccess = function isSuccess() {
    return false;
  };

  _proto3.isFailure = function isFailure() {
    return true;
  };

  _proto3.toString = function toString() {
    return "Result.Error(" + this.error + ")";
  }
  /**
   * **Creates and forwards a brand new Result out of the current error or value **
   */
  ;

  _proto3.forward = function forward() {
    return exports.Result.error(this.error);
  };

  return Err;
}(Base);
//# sourceMappingURL=typescript-result.cjs.development.js.map
